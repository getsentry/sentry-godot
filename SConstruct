#!/usr/bin/env python
import os
import subprocess
from enum import Enum


# *** Settings.

VERSION = "1.0.0-alpha.2"
COMPATIBILITY_MINIMUM = "4.5"


# *** Generate version header.

print("Generating SDK version header...")

git_sha = "unknown"
try:
    cmd = ["git", "rev-parse", "--short", "HEAD"]
    proc = subprocess.Popen(cmd, stdout=subprocess.PIPE)
    git_sha = proc.communicate()[0].strip().decode("utf-8")
except:
    pass

version_header_content = """/* DO NOT EDIT - generated by SConstruct */
#ifndef SENTRY_GODOT_SDK_VERSION_GEN_H
#define SENTRY_GODOT_SDK_VERSION_GEN_H

#define SENTRY_GODOT_SDK_VERSION \"{version}+{git_sha}\"

#endif // SENTRY_GODOT_SDK_VERSION_GEN_H
""".format(version=VERSION, git_sha=git_sha)

if not os.path.exists("src/gen/"):
    os.mkdir("src/gen/")
with open("src/gen/sdk_version.gen.h", "w") as f:
    f.write(version_header_content)


# *** Custom options system.

custom_options = {}
help_entries = []


def add_custom_bool_option(name, description, default=False):
    """Add a custom boolean option with help description."""
    value = ARGUMENTS.get(name, "no" if not default else "yes").lower() in ("yes", "true", "1")
    custom_options[name] = value
    help_entries.append({
        'name': name,
        'description': description,
        'default': default,
        'actual': value
    })


# Define our custom options
add_custom_bool_option("generate_ios_framework", "Generate iOS xcframework from static libraries", False)

# Workaround: Remove custom options from ARGUMENTS to avoid warnings from godot-cpp.
# Godot complains about variables it does not recognize. See: https://github.com/godotengine/godot-cpp/issues/1334
original_arguments = dict(ARGUMENTS)
for key in custom_options.keys():
    if key in ARGUMENTS:
        del ARGUMENTS[key]


# *** Build godot-cpp.

print("Reading godot-cpp build configuration...")
env = SConscript("modules/godot-cpp/SConstruct")

platform = env["platform"]
arch = env["arch"]

# Restore original ARGUMENTS and add custom options to environment
ARGUMENTS.clear()
ARGUMENTS.update(original_arguments)
for name, value in custom_options.items():
    env[name] = value

# Generate help for custom options
help_text = "\nCustom sentry-godot-cocoa options:\n"
for entry in help_entries:
    help_text += f"\n{entry['name']}: {entry['description']} (yes|no)\n"
    help_text += f"    default: {entry['default']}\n"
    help_text += f"    actual: {entry['actual']}\n"
Help(help_text)


# *** Select internal SDK and out_dir.

class SDK(Enum):
    DISABLED = 0
    NATIVE = 1
    ANDROID = 2
    COCOA = 3


if platform in ["linux", "windows"]:
    if arch in ["arm64", "arm32", "rv64"]:
        internal_sdk = SDK.DISABLED
    else:
        internal_sdk = SDK.NATIVE
elif platform in ["macos", "ios"]:
    internal_sdk = SDK.COCOA
elif platform == "android":
    internal_sdk = SDK.ANDROID
else:
    internal_sdk = SDK.DISABLED

# Define output directory for the build target.
out_dir = f"project/addons/sentry/bin/{platform}"
if internal_sdk == SDK.DISABLED:
    out_dir = "project/addons/sentry/bin/noop"
elif internal_sdk == SDK.NATIVE:
    # Separate arch dirs to avoid crashpad handler filename conflicts.
    out_dir += "/" + arch
out_dir = Dir(out_dir)


# *** Build sentry-native.

if internal_sdk == SDK.NATIVE:
    env = SConscript("modules/SConscript.sentry-native", exports=["env"])

    # Deploy crashpad handler to project directory.
    deploy_crashpad_handler = env.CopyCrashpadHandler(out_dir)
    Default(deploy_crashpad_handler)


# *** Utilize sentry-cocoa.

if internal_sdk == SDK.COCOA:
    env = SConscript("modules/SConscript.sentry-cocoa", exports=["env"])


# *** Build GDExtension library.

# Include relative to project source root.
env.Append(CPPPATH=["src/"])

# Source files to compile.
sources = Glob("src/*.cpp")
sources += Glob("src/editor/*.cpp")
sources += Glob("src/sentry/*.cpp")
sources += Glob("src/sentry/processing/*.cpp")
sources += Glob("src/sentry/util/*.cpp")

# Backend-specific sources.
if internal_sdk == SDK.NATIVE:
    sources += Glob("src/sentry/native/*.cpp")
    env.Append(CPPDEFINES=["SDK_NATIVE"])
elif internal_sdk == SDK.ANDROID:
    sources += Glob("src/sentry/android/*.cpp")
    env.Append(CPPDEFINES=["SDK_ANDROID"])
elif internal_sdk == SDK.COCOA:
    sources += Glob("src/sentry/cocoa/*.cpp")
    sources += Glob("src/sentry/cocoa/*.mm")
    env.Append(CPPDEFINES=["SDK_COCOA"])

# Generate documentation data.
if env["target"] in ["editor", "template_debug"]:
    try:
        doc_data = env.GodotCPPDocData(
            "src/gen/doc_data.gen.cpp", source=Glob("doc_classes/*.xml"))
        sources.append(doc_data)
    except AttributeError:
        print("Not including class reference as we're targeting a pre-4.3 baseline.")

build_type = "release" if env["target"] == "template_release" else "debug"
shlib_suffix = env["SHLIBSUFFIX"]
extra = ""


if platform == "ios":
    # *** Build iOS shared library.

    if env["ios_simulator"]:
        extra += ".simulator"

    temp_dir = "project/addons/sentry/bin/ios/temp"
    lib_path = f"{temp_dir}/libsentry.{platform}.{build_type}.{arch}{extra}.dylib"

    library = env.SharedLibrary(
        lib_path,
        source=sources,
    )

    Default(library)
    Clean(library, File(lib_path))

    # Deploy Sentry Cocoa XCFramework for iOS (both device and simulator).
    deploy_cocoa_xcframework = env.DeploySentryCocoa(out_dir)
    Default(deploy_cocoa_xcframework)

    # Generate XCFramework for GDExtension libs if requested
    if env.get("generate_ios_framework", False):
        device_lib = f"{temp_dir}/libsentry.{platform}.{build_type}.arm64.dylib"
        simulator_lib = f"{temp_dir}/libsentry.{platform}.{build_type}.universal.simulator.dylib"
        xcframework_path = f"{out_dir}/libsentry.{platform}.{build_type}.xcframework"

        xcframework = env.CreateXCFrameworkFromLibs(
            framework_path=xcframework_path,
            libraries=[device_lib, simulator_lib],
        )

        env.Depends(xcframework, library)
        Default(xcframework)


elif platform == "macos":
    # *** Build macOS shared library.

    library = env.SharedLibrary(
        f"{out_dir}/libsentry.{platform}.{build_type}.framework/libsentry.{platform}.{build_type}{extra}",
        source=sources,
    )
    Default(library)

    # Deploy Sentry framework for macOS
    deploy_cocoa_framework = env.DeploySentryCocoa(out_dir)
    Default(deploy_cocoa_framework)

else:
    # *** Build shared library on other platforms.

    # Web builds come in two flavors: with threads and without.
    if env["threads"] is False:
        extra += ".nothreads"

    library = env.SharedLibrary(
        f"{out_dir}/libsentry.{platform}.{build_type}.{arch}{extra}{shlib_suffix}",
        source=sources,
    )
    Default(library)


# *** Deploy extension manifest.

manifest = env.Substfile(
    target="project/addons/sentry/sentry.gdextension",
    source="src/manifest.gdextension",
    SUBST_DICT={
        "{compatibility_minimum}": COMPATIBILITY_MINIMUM
    },
)

Default(manifest)


# *** Create symbolic link from project addons dir to gdUnit4 testing framework submodule.

def symlink(target, source, env):
    # Note: parameter `target` is a list of build targets.
    assert len(target) == 1
    assert len(source) == 1
    dst = str(target[0])
    src = str(source[0])
    if platform == "windows":
        # Create NTFS junction.
        # Note: Windows requires elevated privileges to create symlinks, so we're creating NTFS junction instead.
        try:
            import _winapi
            _winapi.CreateJunction(src, dst)
        except Exception as e:
            # Don't fail the build if this step fails.
            print("WARNING: Failed to create NTFS junction for gdUnit4: ", str(e))
    else:
        # Create symlink.
        src = os.path.relpath(src, os.path.dirname(dst))
        os.symlink(src, dst)
    return 0


gdunit_symlink = env.Command(
    "project/addons/gdUnit4",
    "modules/gdUnit4/addons/gdUnit4",
    [
        symlink,
    ],
)

Default(gdunit_symlink)
