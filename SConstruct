#!/usr/bin/env python
import os
import subprocess
import sys
from enum import Enum


# *** Settings.

VERSION = "1.0.0-beta.3"
COMPATIBILITY_MINIMUM = "4.5"


# *** Generate version header.

print("Generating SDK version header...")

git_sha = "unknown"
try:
    cmd = ["git", "rev-parse", "--short", "HEAD"]
    proc = subprocess.Popen(cmd, stdout=subprocess.PIPE)
    git_sha = proc.communicate()[0].strip().decode("utf-8")
except:
    pass

version_header_content = """/* DO NOT EDIT - generated by SConstruct */
#ifndef SENTRY_GODOT_SDK_VERSION_GEN_H
#define SENTRY_GODOT_SDK_VERSION_GEN_H

#define SENTRY_GODOT_SDK_VERSION \"{version}+{git_sha}\"

#endif // SENTRY_GODOT_SDK_VERSION_GEN_H
""".format(version=VERSION, git_sha=git_sha)

if not os.path.exists("src/gen/"):
    os.mkdir("src/gen/")
with open("src/gen/sdk_version.gen.h", "w") as f:
    f.write(version_header_content)


# *** Custom options system.

custom_options = {}
help_entries = []


def add_custom_bool_option(name, description, default=False):
    """Add a custom boolean option with help description."""
    value = ARGUMENTS.get(name, "no" if not default else "yes").lower() in ("yes", "true", "1")
    custom_options[name] = value
    help_entries.append({
        'name': name,
        'description': description,
        'default': default,
        'actual': value
    })


# Define our custom options
add_custom_bool_option("generate_ios_framework", "Generate iOS xcframework from static libraries", False)
add_custom_bool_option("build_android_lib", "Build Android bridge library", False)

# Workaround: Remove custom options from ARGUMENTS to avoid warnings from godot-cpp.
# Godot complains about variables it does not recognize. See: https://github.com/godotengine/godot-cpp/issues/1334
original_arguments = dict(ARGUMENTS)
for key in custom_options.keys():
    if key in ARGUMENTS:
        del ARGUMENTS[key]


# *** Build godot-cpp.

print("Reading godot-cpp build configuration...")
env = SConscript("modules/godot-cpp/SConstruct")

platform = env["platform"]
arch = env["arch"]

# Restore original ARGUMENTS and add custom options to environment
ARGUMENTS.clear()
ARGUMENTS.update(original_arguments)
for name, value in custom_options.items():
    env[name] = value

# Generate help for custom options
help_text = "\nCustom sentry-godot-cocoa options:\n"
for entry in help_entries:
    help_text += f"\n{entry['name']}: {entry['description']} (yes|no)\n"
    help_text += f"    default: {entry['default']}\n"
    help_text += f"    actual: {entry['actual']}\n"
Help(help_text)


# *** Select internal SDK and out_dir.

class SDK(Enum):
    DISABLED = 0
    NATIVE = 1
    ANDROID = 2
    COCOA = 3


if platform in ["linux", "windows"]:
    if arch in ["arm64", "arm32", "rv64"]:
        internal_sdk = SDK.DISABLED
    else:
        internal_sdk = SDK.NATIVE
elif platform in ["macos", "ios"]:
    internal_sdk = SDK.COCOA
elif platform == "android":
    internal_sdk = SDK.ANDROID
else:
    internal_sdk = SDK.DISABLED

# Define output directory for the build target.
out_dir = f"project/addons/sentry/bin/{platform}"
if internal_sdk == SDK.DISABLED:
    out_dir = "project/addons/sentry/bin/noop"
elif internal_sdk == SDK.NATIVE:
    # Separate arch dirs to avoid crashpad handler filename conflicts.
    out_dir += "/" + arch
out_dir = Dir(out_dir)


# *** Build sentry-native.

if internal_sdk == SDK.NATIVE:
    env = SConscript("modules/sentry-native.SConscript", exports=["env"])

    # Deploy crashpad handler to project directory.
    deploy_crashpad_handler = env.CopyCrashpadHandler(out_dir)
    Default(deploy_crashpad_handler)


# *** Utilize sentry-cocoa.

if internal_sdk == SDK.COCOA:
    env = SConscript("modules/sentry-cocoa.SConscript", exports=["env"])

    # Deploy Sentry Cocoa dependency to project directory.
    deploy_cocoa_xcframework = env.DeploySentryCocoa(out_dir)
    Default(deploy_cocoa_xcframework)


# *** Build GDExtension library.

# Include relative to project source root.
env.Append(CPPPATH=["src/"])

# Source files to compile.
sources = Glob("src/*.cpp")
sources += Glob("src/editor/*.cpp")
sources += Glob("src/sentry/*.cpp")
sources += Glob("src/sentry/processing/*.cpp")
sources += Glob("src/sentry/util/*.cpp")

# Backend-specific sources.
if internal_sdk == SDK.NATIVE:
    sources += Glob("src/sentry/native/*.cpp")
    env.Append(CPPDEFINES=["SDK_NATIVE"])
elif internal_sdk == SDK.ANDROID:
    sources += Glob("src/sentry/android/*.cpp")
    env.Append(CPPDEFINES=["SDK_ANDROID"])
elif internal_sdk == SDK.COCOA:
    sources += Glob("src/sentry/cocoa/*.cpp")
    sources += Glob("src/sentry/cocoa/*.mm")
    env.Append(CPPDEFINES=["SDK_COCOA"])

# Generate documentation data.
if env["target"] in ["editor", "template_debug"]:
    try:
        doc_data = env.GodotCPPDocData(
            "src/gen/doc_data.gen.cpp", source=Glob("doc_classes/*.xml"))
        sources.append(doc_data)
    except AttributeError:
        print("Not including class reference as we're targeting a pre-4.3 baseline.")

build_type = "release" if env["target"] == "template_release" else "debug"
shlib_suffix = env["SHLIBSUFFIX"]
extra = ""


if platform == "ios":
    # *** Build iOS shared library.

    if env["ios_simulator"]:
        extra += ".simulator"

    temp_dir = "project/addons/sentry/bin/ios/temp"
    lib_path = f"{temp_dir}/libsentry.{platform}.{build_type}.{arch}{extra}.dylib"

    library = env.SharedLibrary(
        lib_path,
        source=sources,
    )

    Default(library)
    Clean(library, File(lib_path))

    # Generate XCFramework for iOS GDExtension libs if requested
    device_lib = f"{temp_dir}/libsentry.{platform}.{build_type}.arm64.dylib"
    simulator_lib = f"{temp_dir}/libsentry.{platform}.{build_type}.universal.simulator.dylib"
    xcframework_path = f"{out_dir}/libsentry.{platform}.{build_type}.xcframework"

    ios_framework = env.CreateXCFrameworkFromLibs(
        framework_path=xcframework_path,
        libraries=[device_lib, simulator_lib],
    )
    Alias("ios_framework", ios_framework)

    if env.get("generate_ios_framework", False):
        env.Depends(ios_framework, library)
        Default(ios_framework)

elif platform == "macos":
    # *** Build macOS shared library.

    library = env.SharedLibrary(
        f"{out_dir}/libsentry.{platform}.{build_type}.framework/libsentry.{platform}.{build_type}{extra}",
        source=sources,
    )
    Default(library)

else:
    # *** Build shared library on other platforms.

    # Web builds come in two flavors: with threads and without.
    if env["threads"] is False:
        extra += ".nothreads"

    library = env.SharedLibrary(
        f"{out_dir}/libsentry.{platform}.{build_type}.{arch}{extra}{shlib_suffix}",
        source=sources,
    )
    Default(library)

# *** Build Android lib

if sys.platform.startswith("win"):
    gradle_cmd = "gradlew.bat assemble"
else:
    gradle_cmd = "./gradlew assemble"

# Use new environment importing current shell's env for greater compatibility.
env_gradle = Environment(ENV = os.environ)

android_lib = env_gradle.Command(
    target=[
        "project/addons/sentry/bin/android/sentry_android_godot_plugin.debug.aar",
        "project/addons/sentry/bin/android/sentry_android_godot_plugin.release.aar"
    ],
    source=[Dir("android_lib/")],
    action=[gradle_cmd]
)
env_gradle.NoCache(android_lib)
env_gradle.AlwaysBuild(android_lib)

Alias("android_lib", android_lib)

if env.get("build_android_lib", False):
    Default(android_lib)
    Depends(android_lib, library)


# *** Add help for optional targets.

Help("""
Optional targets:

ios_framework: Create iOS XCFramework from device and simulator builds.
               Usage: scons target=template_release platform=ios ios_framework
               Note: Requires both device and simulator builds to exist, and it
                     doesn't trigger a build.

android_lib: Build Android bridge library.
             Usage: scons target=template_release platform=android android_lib
""")


# *** Deploy extension manifest.

manifest = env.Substfile(
    target="project/addons/sentry/sentry.gdextension",
    source="src/manifest.gdextension",
    SUBST_DICT={
        "{compatibility_minimum}": COMPATIBILITY_MINIMUM
    },
)

Default(manifest)


# *** Create symbolic link from project addons dir to gdUnit4 testing framework submodule.

def symlink(target, source, env):
    # Note: parameter `target` is a list of build targets.
    assert len(target) == 1
    assert len(source) == 1
    dst = str(target[0])
    src = str(source[0])
    if platform == "windows":
        # Create NTFS junction.
        # Note: Windows requires elevated privileges to create symlinks, so we're creating NTFS junction instead.
        try:
            import _winapi
            _winapi.CreateJunction(src, dst)
        except Exception as e:
            # Don't fail the build if this step fails.
            print("WARNING: Failed to create NTFS junction for gdUnit4: ", str(e))
    else:
        # Create symlink.
        src = os.path.relpath(src, os.path.dirname(dst))
        os.symlink(src, dst)
    return 0


gdunit_symlink = env.Command(
    "project/addons/gdUnit4",
    "modules/gdUnit4/addons/gdUnit4",
    [
        symlink,
    ],
)

Default(gdunit_symlink)
